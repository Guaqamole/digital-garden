---
tags:
  - "#interview-process"
---
실행 방법 : ctrl + r
flash 카드 등록 방법: Spaced Repetition 들어가서 flashcards tags 등록

### 프로세스가 뭔가요?
``
<mark style="background: #C6AB16;">메모리에 로드</mark>되어 <mark style="background: #C6AB16;">CPU의 자원</mark>과 <mark style="background: #C6AB16;">주소 공간</mark>을 할당을 받고 <mark style="background: #C6AB16;">실행되고 있는 프로그램</mark>

### 프로세스와 프로그램과 어떤 차이가 있나요?
``
<mark style="background: #C6AB16;">정적 상태인 프로그램</mark>과 달리 <mark style="background: #C6AB16;">메모리에 주소 공간</mark>을 갖는 <mark style="background: #C6AB16;">능동</mark>적인 객체

### 프로세스와 스레드와 어떤 차이가 있나요?
``
프로세스가 할당 받은 자원을 이용하는 실행 단위


### 프로세스 실행 과정을 말해주세요
``
1. 디스크에서 코드와 데이터가 담긴 프로그램이 메모리에 로드됨
2. PID 생성 후 프로세스 테이블에 삽입
3. 새로운 가상 주소 공간이 할당됨
4. PCB가 생성되며 PID 값을 채우고 SP, PC를 제외한 대부분 영역을 0으로 초기화
5. 프로세스 상태값이 ready로 변경되고 Queue에서 대기
6. 프로세스 실행

### 프로세스 상태 종류에 대해 말해주세요
``
1. new - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
2. ready - CPU 자원을 얻을때 까지 기다리는 상태
3. running - CPU 자원을 얻어 실제 작업을 수행하는 상태
4. waiting - 이벤트를 기다리는 상태
5. terminated - 프로세스가 작업을 완료한 상태

### 프로세스 라이프 사이클에 대해 설명해주세요
``
1. 보조기억장치에서 스풀링을 거쳐 프로그램이 메모리에 로드됨
2. ready 상태 프로세스는 디스패치를 통해 running 상태로 전환
3. running 상태에서 인터럽트 / 시스템콜 발생시 wait 상태로 전환
4. wait 상태에서 인터럽트 / 시스템콜 완료시 ready 상태로 전환
5. running 상태에서 Timer Run Out 발생시 ready 상태로 전환
6. wait 상태에서 재시작 / 중단시 suspend 상태로 전환
![](https://i.imgur.com/G8AuL2Z.png)

### PCB가 무엇이고, 어떤 내용이 들어있나요 (5가지)?
``
각 프로세스에 대한 정보를 저장하는 운영체제의 자료구조:
1. Pointer
2. Process iD
3. Process State
4. Program Counter
5. Register

### 그렇다면, 스레드는 PCB를 가지고있나요?
``
아니요, 하지만 thread 정보를 저장하는 TCB가 존재한다:
1. PCB Pointer
2. Thread ID
3. CPU Info
4. Thread State

### 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
``
프로세스: 실행 중인 프로세스가 fork() 시스템 콜을 호출하여 새로운 프로세스를 생성하고 부모 / 자식 관계 형성
스레드: POSIX 시스템에선 pthread_create 명령어를 통해 생성

### fork() 와 exec() 의 차이는 뭔가요?
``
fork: 기존의 프로세스를 복제하여 새로운 프로세스를 생성
exec(): 이미 확보된 메모리 공간은 그대로 두고 그 안의 내용을 바꿔 다른 프로세스로 전환
![](https://i.imgur.com/oG3c5zW.png)

### 자식 프로세스가 상태를 알리지 않고 죽으면 어떻게 처리하나요 (해결방법 포함)?
``
자식이 먼저 죽으면 좀비프로세스
1. 자식이 상태를 알리지 않고 죽으면 프로그램이 정상 종료되지 않으므로 exit() 명령어를 호출하지 않는다. 
2. 부모는 자식의 exit() 명령어를 통해 wait() 을 호출하는데 해당 명령어가 수행되지 않으면 자원이 반납되지 않는다
3. 해결 방법은 부모 프로세스가 wait 함수를 호출 하는것이다.

### 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요 (해결방법 포함)?
``
부모가 먼저 죽으면 고아 프로세스
1. 부모 프로세스가 먼저 죽게되면 wait을 호출 할 수 없게된다
2. 자식 프로세스는 새로운 부모 프로세스로 init(pid=1)이 설정된다.
3. 해결 방법은 자식 프로세스가 종료될 때 까지 기다린 후 init은 wait을 호출

### 리눅스에서 데몬 프로세스에 대해 설명해주세요
``
프로세스는 포어그라운드(foreground) 프로세스와 백그라운드(background) 프로세스로 나뉜다.
- 포어그라운드: 사용자와 대화할 수 있는 표준 입출력 장치 즉, 터미널과 키보드(tty 또는 pts)를 사용
- 백그라운드: 사용자에게 어떤 장치를 통해 값을 전달받는 것이 아니라, 스스로 동작
- 데몬은 백그라운드 프로세스에 속하기 때문에 백그라운드 프로세스와 마찬가지로 TTY(터미널 장치)를 가지고 있지 않으며, 추가로 PPID(parent id)가 1이고, SID(session id) 역시 자신의 아이디와 같다

### 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
``
init 프로세스는 시스템 부팅 시 가장 먼저 시작되고 다른 모든 프로세스의 부모 프로세스가된다. 이후 init 프로세스는 시스템의 다양한 서비스와 데몬을 시작하고 관리한다.



# 프로세스가 무엇인가요?

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled.png?lastModify=1711704186)

- 메모리에 로드되어 CPU의 할당을 받고 실행되고 있는 프로그램
    
    프로그램과 달리 메모리에 주소 공간을 갖는 능동적인 객체
    
    프로세스 = 프로그램의 코드 + 데이터 + 실행 상태 + 관련 리소스
    
    ### 프로세스 라이프사이클
    
    ### 생성 과정
    
    1. 프로그램 로딩: 디스크에서 프로그램을 로딩 → 코드와 데이터가 메모리에 로드됨
        
    2. PID 생성 후 Process 테이블 삽입
        
        ![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%202.png?lastModify=1711704164)
        
    3. 프로세스 주소 공간 (메모리) 설정: 새로운 가상 주소 공간이 할당됨 (코드, 데이터, 스택)
        
        ![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%203.png?lastModify=1711704164)
        
    4. 프로세스 초기화
        
        1. PCB가 생성되며 OS가 실행한 프로그램의 코드를 읽어 Text Segment에 저장
            
        2. PDB에는 프로세스 아이디, 상태, 우선순위, Thread Control Block 리스트 등의 정보가 저장됨
            
        3. 부모 프로세스 관계 설정: 첫 번째 단계에서 생성한 PID를 PID 영역에 채우고, 부모 프로세스 아이디도 채움
            
        4. 스택 포인터와 프로그램 카운터를 제외한 대부분의 영역은 0으로 채움
            
        5. PCB에 정보가 기록되면 상태값이 ready로 변경되고 Ready Queue에서 대기
            
    5. 프로세스 실행
        
    
    ### 프로세스 이미지 & 테이블
    
    ![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%204.png?lastModify=1711704186)
    
    프로세스는 각각의 프로세스 이미지를 가진다. 프로세스 이미지는 데이터, 프로그램, 스택, PCB를 가진다.
    
    ![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%205.png?lastModify=1711704164)
    
    ### 프로세스 상태
    
    ![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%206.png?lastModify=1711704164)
    

## 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%207.png?lastModify=1711704186)

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%208.png?lastModify=1711704164)

- 프로그램: **컴퓨터에서 어떤 작업을 위해 실행할 수 있는 '정적인 상태'의 파일**
    
- 프로세스: **컴퓨터에서 연속적으로 실행되고 있는 '동적인 상태' (실행중인) 프로그램**
    
    - CPU 시간 및 주소공간 (code, data, stack, heap) 할당받음
        
- 스레드: **프로세스가 할당 받은 자원을 이용하는 실행 단위이자,** 프로세스의 하나의 실행 단위
    

## PCB가 무엇인가요?

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%209.png?lastModify=1711704186)

- 각 프로세스에 대한 정보를 저장하는 운영체제의 자료구조
    

1. 프로세스 식별자(Process ID) : 프로세스 고유 번호
    
2. 프로세스 상태(Process State) : 생성(create), 준비(ready), 실행 (running), 대기(waiting), 완료(terminated)
    
3. 프로그램 계수기(Program Counter) : 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.
    
4. CPU 레지스터 및 일반 레지스터 : CPU(Central Processing Unit)가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
    
5. CPU 스케줄링 정보 : 우선 순위, 최종 실행시각, CPU 점유시간 등
    
6. 메모리 관리 정보 : 해당 프로세스의 주소 공간 등
    
7. 프로세스 계정 정보 : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
    
8. 입출력 상태 정보 : 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등
    
9. 포인터 : 부모프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등. 프로세스가 준비상태나 대기 상태일 경우에 큐로 운영이 되는데, 프로세스 제어 블록을 연결 시 큐로 구현하기 위해 포인터를 사용한다.
    

## 그렇다면, 스레드는 PCB를 갖고 있을까요?

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%2010.png?lastModify=1711704164)

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%2011.png?lastModify=1711704164)

- 스레드는 PCB를 갖고 있지 않지만, thread의 상태, PCB를 가리키는 Pointer, 우선순위, 스택, 레지스터 등 thread의 정보를 저장하는 TCB가 존재 (linked list로 구현됨)
    
- 1. **스레드 ID** : 스레드가 생성될 때 운영 체제에서 스레드에 할당하는 고유 식별자
        
        2. **스레드 상태**: 스레드가 시스템을 통해 진행됨에 따라 변경되는 스레드의 상태
            
        3. **CPU 정보**: 스레드가 얼마나 진행되었는지, 어떤 데이터가 사용되고 있는지 등 OS가 알아야 하는 모든 정보가 포함스레드
            
        4. **우선 순위**: 스레드 스케줄러가 READY 대기열에서 다음에 선택해야 하는 스레드를 결정하는 데 도움이 되는 다른 스레드에 대한 스레드의 가중치(또는 우선 순위)
            
        5. **PCB를 가리키는 포인터** : 이 스레드 생성을 트리거한 프로세스를 가리키는 포인터
            
        6. **이 스레드가 생성한 스레드를 가리키는 포인터**
            
        7. **stack 포인터** ( stack : 스레드가 함수 호출할때 저장하는 곳)
            
- 메모리영역 중 PCB는 커널 영역TCB는 유저영역과 커널 영역에 둘다 있을 수 있다.
    

## 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

- 리눅스에서 프로세스와 스레드는 모두 fork() 또는 clone() 시스템 콜을 사용하여 생성
    
- 프로세스는 실행 중에 프로세스 생성 시스템을 호출하여 새로운 프로세스를 생성할 수 있다. 이에 따라 부모/자식 관계를 유지하며 계층적으로 생성된다.
    
- 따라서 프로세스가 생성되기 위해서는 부모 프로세스와 생성 요청을 하기 위한 시스템콜이 필요하다
    
- 시스템을 부팅할 때 Swapper, Pagedaemon, Init 이렇게 3개의 프로세스가 생성되는데, 이를 커널 프로세스라고 한다. 그리고 모든 사용자 프로세스는 fork() 명령을 통해 계층적으로 Init의 자식 프로세스로 생성된다.
    
- fork() : fork() 시스템콜을 통해 부모 프로세스를 복제하여 새로운 자식 프로세스를 생성
    
- exec() : exec() 시스템콜을 통해서는 프로세스 내용을 새로운 프로세스로 대체
    
- fork vs clone
    

일반적으로 POSIX 시스템에서는 **`pthread_create()`** 함수를 사용하여 새로운 스레드를 생성합니다. 이 함수는 새로운 스레드를 현재 프로세스 내에서 생성하며, 부모 프로세스와는 별개의 스레드가 됩니다. 스레드는 동일한 주소 공간을 공유하므로, 부모 프로세스의 데이터와 자원에 쉽게 접근할 수 있습니다.

fork is a wrapper function for the clone system call. it sets paramters that are needed to implement the POSIX standard fork function. it is also used by the vfork function.

The clone function is what creates the kernel supporting threads. The resulting threads are subject to the same scheduling that is done for all processes.

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%2012.png?lastModify=1711704164)

- 그외 (궁금한사람만)
    
    1. **exec 계열 명령어**: 새로운 프로그램을 실행하는데 사용됩니다. 대표적으로는 **`execve`**, **`execl`**, **`execv`**, **`execvp`** 등이 있습니다.
        
    2. **pthread_create**: POSIX 스레드를 생성하는 데 사용됩니다. 새로운 스레드를 만들고 해당 스레드가 실행할 함수를 지정할 수 있습니다.
        
    3. **vfork**: 새로운 프로세스를 생성하는데 사용되며, 부모 프로세스와 자식 프로세스가 메모리 공간을 공유합니다. **`fork()`**와 달리 자식 프로세스는 부모 프로세스의 메모리를 변경할 수 없습니다.
        
    4. **posix_spawn**: 새로운 프로세스를 생성하는데 사용됩니다. **`fork()`**와 **`exec()`**를 단일 호출로 결합하여 사용할 수 있습니다.
        
    5. **system**: 셸 명령어를 실행하는데 사용됩니다. 주어진 명령어를 셸에 전달하여 실행합니다.
        
    6. **popen**: 외부 프로세스를 실행하고 해당 프로세스의 입출력 스트림을 파이프로 연결하는 데 사용됩니다.
        
    7. **forkpty**: 새로운 가상 터미널 세션을 생성하고 새로운 프로세스를 실행하는데 사용됩니다. 대개 터미널 애플리케이션을 프로그래밍적으로 제어할 때 사용됩니다.
        

## 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요? (다시해야함)

## 자식이 먼저 죽음 (좀비)

프로세스가 종료 될 때, 마지막 문장의 실행을 끝내고, `exit()` 시스템 호출을 사용하여 운영체제에게 자신의 삭제를 요청하면서 종료된다.

이 시점에서, 프로세스는 자신의 부모가 호출한 `wait()` 시스템 호출을 통해서, 상태 값을 반환할 수 있고, 물리 메모리와 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 운영체제로 반납된다

프로세스가 종료되면 사용하던 자원은 운영체제가 되찾아가게 된다. 그러나 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모 프로세스가 `wait()`을 호출할 때까지 남아있게 된다.

따라서 종료가 되었지만 부모 프로세스가 아직 `wait()` 호출을 하지 않은 프로세스를 좀비 (`zombie`) 프로세스라고 한다.

→ 좀비 프로세스는 최소한의 정보만을 가지고 있어 큰 성능 저하를 야기하지 않지만, 운영체제는 한정된 PID를 가지고 있으므로 좀비 프로세스가 PID를 차지하며 다른 프로세스 실행을 방해하게 됩니다.

따라서 부모 프로세스는 좀비 프로세스 생성을 방지하기 위해 wait 함수를 호출하여 상태를 회수해야한다.

## 부모가 먼저 죽음 (고아)

고아 프로세스는 부모 프로세스가 `wait()`을 호출하는 대신에 그냥 종료를 해버리는 것이다. 부모 프로세스가 먼저 종료되면 자식 프로세스의 새로운 부모 프로세스로 init(PID = 1) 설정된다

init 프로세스는 자식 프로세스가 종료될 때까지 기다린 후 wait 함수를 호출하여 고아 프로세스의 종료 상태를 회수하여 좀비 프로세스가 되는 것을 방지

→ 고아 프로세스는 프로세스 자신이 시스템의 자원을 낭비할 수 있고, 시스템이 프로세스가 종료될 때까지 추적을 해야 하기 때문에 성능 저하의 원인이 됨

## 리눅스에서, 데몬프로세스에 대해 설명해 주세요.

프로세스는 포그라운드(foreground) 프로세스와 백그라운드(background) 프로세스로 나눌 수 있습니다.

**포그라운드 프로세스**의 경우 사용자와 대화할 수 있는 표준 입출력 장치 즉, 터미널과 키보드(tty 또는 pts)를 사용하지만, **백그라운드 프로세스**의 경우 사용자에게 어떤 장치를 통해 값을 전달받는 것이 아니라, 스스로 동작하는 프로세스를 의미

데몬은 백그라운드 프로세스에 속하기 때문에 백그라운드 프로세스와 마찬가지로 TTY(터미널 장치)를 가지고 있지 않으며, 추가로 PPID(parent id)가 1이고, SID(session id) 역시 자신의 아이디와 같다는 특징

## 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%2013.png?lastModify=1711704164)

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%2014.png?lastModify=1711704186)

- 시스템 부팅 시 가장 먼저 시작되고 다른 모든 프로세스의 부모 프로세스
    
- 이후 init 프로세스는 시스템의 다양한 서비스와 데몬을 시작하고 관리
    
    - 시스템 서비스, 네트워크 서비스, 로그인 서비스 등을 실행하고 이를 유지 관리
        

## 추가* 프로세스 & 스레드가 어떻게 자원을 공유하는지 설명하세요.

### 프로세스

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%2015.png?lastModify=1711704186)

- IPC(Inter-Process Communication)
    
- LPC(Local inter-Process Communication)
    
- 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정
    

프로세스 자원 공유는 단순히 CPU 레지스터 교체뿐만이 아니라 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 **자원 부담이 크다는 단점**이 있다 → 다중 작업이 필요한경우 스레드를 이용하는 것이 훨씬 효율적이라, 현대 컴퓨터의 운영체제에선 다중 프로세싱을 지원하고 있지만 다중 스레딩을 기본으로 사용.

### 스레드

![Untitled](file:///Users/avokey/Downloads/b9a56ddf-b0a4-424a-8550-744acc759b60_Export-e7e8ee11-4f9b-4b7c-bd98-1fc77de11b9b/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%80%E1%85%A1%20%E1%84%86%E1%85%AE%E1%84%8B%E1%85%A5%E1%86%BA%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%80%E1%85%A1%E1%84%8B%E1%85%AD%2039c5216df78748b097b8704fcf8fd547/Untitled%2016.png?lastModify=1711704186)

- 스레드끼리 **프로세스의 자원을 공유**하면서 프로세스 실행 흐름의 일부가 되기 때문에 동시 작업이 가능
    
- 프로세스의 4가지 메모리 영역(Code, Data, Heap, Stack) 중 스레드는
    
    - Stack만 할당받아 복사
        
    - Code, Data, Heap은 프로세스내의 다른 스레드들과 **공유**된다.
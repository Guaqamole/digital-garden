---
title: 성능 테스트
date: 2024-02-27
draft: false
tags:
  - Testing
complete: true
---
## 성능 테스트란 무엇일까요?

‘성능 테스트’란 서비스 및 서비스 시스템의 성능을 확인하기 위해 실제 사용 환경과 비슷한 환경에서 테스트를 진행하는 것을 말합니다. 성능 테스트를 통하여 응답시간(Response Time), 처리량(Throughput), 병목 구간 등을 확인할 수 있고, 성능 테스트로 얻은 정보로 서비스나 시스템의 문제점을 확인하고 이를 개선(Tuning)하여 보완할 수 있습니다. *출처 : Apache JMeter 오픈소스로 대용량 웹 서비스 성능 테스트하기

## 성능 테스트는 왜 해야 할까?

2019년 열린 ‘MSC 2019’ 행사에서 발표된 내용 중 “디지털 마케팅 시대, 웹에서 속도가 고객 경험을 결정한다. 마케터들의 핵심성과평가(KPI) 개선에는 고객 경험이 중요하고 이는 웹 속도가 좌우한다.” 라는 내용이 있었습니다. "49%의 고객이 2초 이하의 로딩 속도를 기대하고, 18%의 고객은 1초도 지체 없는 로딩 속도를 기대한다는 2년 전 자료가 있다"라며 "로딩 속도 1초가 빨라지면 아마존 판매량이 1% 증가하고 구글 검색량 0.2% 증가, 월마트의 전환율이 2% 증가 한다"고 설명했습니다.

덧붙여 "아마존 판매량을 환산하면 68억 달러, 구글의 검색량 증가로 4억 5천만 달러의 광고 노출, 월마트의 2억 4천400만 달러의 매출이 늘어나는 셈"이라고 강조했습니다. 그만큼 웹 서비스의 응답 시간, 즉 성능이 중요하다는 거겠죠?

또, 쉽게 주변에서 일어나는 상황을 예로 들어보면 대학 수강 신청, 인기 있는 아이돌의 콘서트 예매, 프로야구 한국시리즈 예매 등 순간적으로 동시 접속자들이 늘어날 때 예매 사이트 서버가 다운되는 경우들을 많이 볼 수 있습니다.

**성능 테스트는 서비스 및 서비스 시스템이 작업 부하 상태에서 제대로 작동하는지 확인하는 일종의 소프트웨어 테스트입니다. 성능 테스트의 목적은 버그를 찾는 것이 아니라 성능 병목 현상을 제거하는 것입니다.**
**​**
성능 테스트는 서비스 및 서비스 시스템의 속도, 확장성 및 안정성에 대한 정보를 이해 관계자에게 제공 해당 제품이 시장에 출시되기 전에 필요한 개선이 필요하다는 것을 보여줍니다. 성능 테스트를 통해 여러 사용자가 동시에 사용하는 동안 서비스 및 서비스 시스템이 다운되거나 느리게 실행되지 않도록 할 수도 있습니다.

쉽게 주변에서 일어나는 상황을 예로 들어보면 대학 수강 신청, 인기 있는 아이돌의 콘서트 예매, 프로야구 한국시리즈 예매 등 순간적으로 동시 접속자들이 늘어날 때 예매 사이트 서버가 다운되는 경우들을 많이 볼 수 있습니다.

위 상황들은 1회성이 아닌 다분히 발생하고 있는 Case임에도 불구하고 이벤트가 있을 때마다 서버 다운이 불가피한 상황입니다.

**특정 이벤트에 대해 미리 동시 접속자 수에 대한 성능 테스트를 수행함으로써 서버가 몇 명까지의 동시 접속자 수를 케어할 수 있는지, 어디에서 부하가 많이 발생하는지 사전에 미리 예측하고 대비할 수 있습니다.**


## 성능 테스트 유형

일반적으로 성능 테스트의 유형은 다음 4가지로 정의하고 있습니다.

1) Load Test : 동시 사용자 또는 프로세스 수에 의해 생성되는 트랜잭션의 요청으로 인해 현실적인 부하 수준을 처리하는지에 대한 시스템 성능 측정

2) Stress Test : 임계값 이상의 요청이나 비정상적인 요청을 보내 비정상적인 상황의 처리 상태를 확인하고 시스템의 최고 성능 한계를 측정하기 위한 테스트

3) Spike Test : 갑자기 사용자가 몰렸을 때 요청이 정상적으로 처리되는지, 또는 업무 부하가 줄어들 때 정상적으로 반응하는지를 확인

3) Scalability Test / Soak Test : 긴 시간 동안 테스트를 진행해서 테스트 시간에 따른 시스템의 메모리 증가, 성능 정보의 변화 등을 확인

![](https://i.imgur.com/FASf553.png)

**단위 성능**: 하나의 성능만 테스트
**임계 성능**: 시스템이 어디까지 버틸 수 있는지 측정
**통합 성능 테스트**: 전체 시스템의 성능을 평가
​
### 방법에 따른 분류
![](https://i.imgur.com/h8NzU0a.png)

**Loop Back**: 영향이 가면 되는곳까지만 테스트 진행
**Spike**: 이벤트성 부하 테스트 → 타임세일, 쿠폰 결제

## 성능 지표
![](https://i.imgur.com/OKMyZ1n.png)


## 성능 테스트 용어
#### Response Time - 응답 시간
- 사용자가 request한 시점에서 시스템이 Response할 때까지의 시간
![](https://i.imgur.com/mWVaQx9.png)

#### Visit Time - 방문시간
![](https://i.imgur.com/VTucvvM.png)


#### 요청 주기(Request Interval), Think Time
![](https://i.imgur.com/kNzsVZc.png)

![](https://i.imgur.com/Sb5ZYJ1.png)

#### Active User
- Request 요청을 하여 응답을 기다리는 사용자
- Active User = TPS * Average Response Time
![](https://i.imgur.com/JzMy9YT.png)


#### Throughput - 처리량
- 단위: tph, tpm, tps, pps, rps, hit/sec
![](https://i.imgur.com/ViK0EyE.png)

#### Saturation Point - 임계점
- 최대 TPS가 나타나는 최초의 지점
- Saturation Point가 넘어 사용자가 몰리면 TPS는 고정된 상태에서 응답시간이 길어진다.
![](https://i.imgur.com/gczCdnE.png)


그외 성능 테스트에서 사용하는 용어를 살펴보도록 하겠습니다.

1) Active User : 실제 서버에 연결된 상태로 요청을 처리 중인 사용자

2) Inactive User : 웹브라우저에 결과 화면이 출력된 상태에서 화면의 내용을 읽거나 정보를 입력하고 있는 사용자

3) Concurrent User : 특정 시점에 시스템에 접속하여 사용하고 있는 사용자

	※ Concurrent User = Active User + Inactive User

4) Virtual User : 가상 사용자 수, Apache JMeter에서는 Thread 수로 표현하기도 함

5) Response Time/Load Time : 응답시간 또는 처리시간, 요청을 보낸 후 응답이 완료되어 사용자 화면에 출력될 때까지의 시간

6) Latency : 요청을 보낸 후 데이터를 받기 시작할 때까지 시간

7) Think Time : 하나의 요청에 응답을 수신하고 다음 요청을 보낼 때까지 시간

8) Request Interval Time : 요청을 보낸 후 다음 요청을 보낼 때까지 시간

9) Ramp-Up Period : Thread 생성에 걸리는 시간

10) Transaction : 업무 처리의 단위, 화면 조작 및 응답을 트랜잭션으로 정의

11) Throughput : 단위 시간당 대상 서버에서 처리되는 요청의 수, Apache JMeter에서는 시간 단위를 보통 TPS(Transaction Per Second)로 표현하며 TPM(Transaction Per Minute), TPH(Transaction Per Hour) 등이 있음

## 성능테스트 계산식

### HPS
```
HPS(hit per second) = 시스템이 처리할 수 있는 모든 웹 요청의 초당 처리
```

### TPS
```
TPS = Active User / Average Response Time(s)

Active User = TPS * Average Response Time(s)
```

### Active User
```
TPS = Active User / Average Response Time(s)

TPS = Concurrent User / Request Interval
```

```
Active User = Concurrent User * Response Time / Request Interval Time

Request Interval Time = Response Time + Think Time

Active User = Concurrent User * Response Time / (Response Time + Think Time)
  ```

### Concurrent User
```
TPS = **Active User** / Average Response Time(s)

**Active User** = Concurrent User * Response Time / (Response Time + Think Time)

  **- Concurrent User** = Active User * ( 1 + (Think Time / Response Time))

      **- Concurrent User** = Active User + (TPS * Think Time)

          **- Concurrent User** = TPS * (Response Time + Think Time)
```

### 목표 TPS구하기
```
Concurrent User = 2000

Average Response Time = 0.5s

Think Time = 10s

수식: **Active User** = Concurrent User * Response Time / (Response Time + Think Time)

Active User*= 2000 * 0.5 / (0.5 + 10) = 95.23 = TPS(s)
```
